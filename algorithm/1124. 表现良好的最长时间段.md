# 1124. 表现良好的最长时间段

## 前置知识：前缀和

对于数组 $nums$，定义它的前缀和 $s[0]=0,s[i+1] = \sum\limits_{j=0}^{i}nums[j]$。

例如 $nums=[1,2,−1,2]$，对应的前缀和数组为 $s=[0,1,3,2,4]$。

通过前缀和，我们可以把子数组的元素和转换成两个前缀和的差，即

$\sum\limits_{j=left}^{right}nums[j]=\sum\limits_{j=0}^{right}nums[j]-\sum\limits_{j=0}^{left-1}nums[j]=s[right+1]-s[left]$

例如 $nums$ 的子数组 $[2,−1,2]$ 的和就可以用 $s[4]−s[1]=4−1=3$ 算出来。

注：为方便计算，常用左闭右开区间 $[left,right)$ 来表示子数组，此时子数组的和为 $s[right]−s[left]$，子数组的长度为 $right−left$。

方法一：单调栈
先把问题转换到我们熟悉的东西上。

「劳累天数大于不劳累天数」等价于「劳累天数减去不劳累天数大于 000」。

那么把劳累的一天视作 nums[i]=1\textit{nums}[i]=1nums[i]=1，不劳累的一天视作 nums[i]=−1\textit{nums}[i]=-1nums[i]=−1，则问题变为：

计算 nums\textit{nums}nums 的最长子数组，其元素和大于 000。

既然说到了「子数组的元素和」，那么利用前缀和 sss，将问题变为：

找到两个下标 iii 和 jjj，满足 j<ij<ij<i 且 s[j]<s[i]s[j]<s[i]s[j]<s[i]，最大化 i−ji-ji−j 的值。

想一想，哪些值可以作为 jjj（最长子数组的左端点）呢？



答疑
问：我怎么觉得这题和我做过的单调栈题目不太一样呢？没法快乐套模板

答：通常的单调栈题目（例如 496. 下一个更大元素 I）都是求的「最近」或「最短」，本题求的是「最长」，不能一概而论。就当成是新的模板

Python3
Java
C++
Go
class Solution:
    def longestWPI(self, hours: List[int]) -> int:
        n = len(hours)
        s = [0] * (n + 1)  # 前缀和
        st = [0]  # s[0]
        for j, h in enumerate(hours, 1):
            s[j] = s[j - 1] + (1 if h > 8 else -1)
            if s[j] < s[st[-1]]: st.append(j)  # 感兴趣的 j
        ans = 0
        for i in range(n, 0, -1):
            while st and s[i] > s[st[-1]]:
                ans = max(ans, i - st.pop())  # [st[-1],i) 可能是最长子数组
        return ans
复杂度分析
时间复杂度：O(n)O(n)O(n)，其中 nnn 为 hours\textit{hours}hours 的长度。注意每个元素至多入栈出栈各一次，因此二重循环的时间复杂度是 O(n)O(n)O(n) 的。
空间复杂度：O(n)O(n)O(n)。
方法二：利用前缀和的连续性
虽说方法一更加通用，不过利用 nums\textit{nums}nums 中只有 111 和 −1-1−1 的特点，可以做到一次遍历。

考虑 s[i]s[i]s[i]：

如果 s[i]>0s[i]>0s[i]>0，那么 j=0j=0j=0 就是最远的左端点，因为 s[0]=0s[0]=0s[0]=0，故 s[i]−s[0]=s[i]>0s[i]-s[0]=s[i]>0s[i]−s[0]=s[i]>0，符合要求。
如果 s[i]≤0s[i]\le 0s[i]≤0，那么 jjj 就是 s[i]−1s[i]-1s[i]−1 首次出现的位置。为什么是 s[i]−1s[i]-1s[i]−1 而不是其它更小的数？这是因为前缀和是从 000 开始的，由于 nums\textit{nums}nums 中只有 111 和 −1-1−1，那么相邻前缀和的差都恰好为 111，要想算出比 s[i]−1s[i]-1s[i]−1 更小的数，必然会先算出 s[i]−1s[i]-1s[i]−1，那么这些更小数必然在 s[i]−1s[i]-1s[i]−1 首次出现的位置的右边。


代码实现时，可以用哈希表记录每个 s[i]s[i]s[i] 首次出现的下标。

不过，由于我们只需要考虑值在闭区间 [−n,0][-n,0][−n,0] 内的前缀和，用数组记录是更加高效的。同时，为了避免用负数访问数组，可以在计算过程中把前缀和取反。

Python3
Java
C++
Go
class Solution:
    def longestWPI(self, hours: List[int]) -> int:
        pos = [0] * (len(hours) + 2)  # 记录前缀和首次出现的位置
        ans = s = 0
        for i, h in enumerate(hours, 1):
            s -= 1 if h > 8 else -1  # 取反，改为减法
            if s < 0:
                ans = i
            else:
                if pos[s + 1]:  # 原本是 s-1，取反改为 s+1
                    ans = max(ans, i - pos[s + 1])  # 这里手写 if 会更快
                if pos[s] == 0:
                    pos[s] = i
        return ans
复杂度分析
时间复杂度：O(n)O(n)O(n)，其中 nnn 为 hours\textit{hours}hours 的长度。
空间复杂度：O(n)O(n)O(n)。

作者：灵茶山艾府
链接：https://leetcode.cn/problems/longest-well-performing-interval/solutions/2110211/liang-chong-zuo-fa-liang-zhang-tu-miao-d-hysl/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。